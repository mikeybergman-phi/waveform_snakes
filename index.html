<!DOCTYPE html>
<html lang="en">
head>
  <meta charset="UTF-8" />
  <title>Waveform Snakes â€“ Auto BPM + Per-Sound Brightness</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: system-ui, sans-serif;
      color: #eee;
    }
    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      padding: 10px 12px;
      background: rgba(0, 0, 0, 0.78);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      z-index: 10;
      max-width: 310px;
      font-size: 12px;
      backdrop-filter: blur(8px);
    }
    #controls h1 {
      font-size: 14px;
      margin: 0 0 6px;
      font-weight: 600;
      letter-spacing: 0.03em;
    }
    #controls .row {
      margin-bottom: 6px;
      display: flex;
      flex-direction: column;
    }
    #controls label {
      font-size: 11px;
      margin-bottom: 2px;
      display: flex;
      justify-content: space-between;
      gap: 6px;
      white-space: nowrap;
    }
    #controls input[type="range"] { width: 100%; }
    #controls button {
      margin-top: 6px;
      padding: 6px 8px;
      background:#181818;
      color:#eee;
      border-radius:6px;
      border:1px solid #555;
      cursor:pointer;
      font-size:11px;
    }
    #controls button:hover { background:#252525; }
    #controls input[type="file"] {
      margin-top:4px;
      font-size:11px;
    }
    #hint {
      font-size:10px;
      opacity:0.8;
      margin-top:4px;
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="controls">
    <h1>Waveform Snakes â€“ Auto BPM ðŸŒˆ</h1>

    <button id="micBtn">Use Microphone</button>
    <input id="fileInput" type="file" accept="audio/*">

    <div id="hint">
      Each beat â†’ one waveform loop eating its tail.<br>
      If audio is silent / blocked, it falls back to an ambient pulse.<br>
      Rainbow Brightness = max; each loop picks a random value â‰¤ that.
    </div>

    <div class="row">
      <label><span>Fade</span><span id="fadeVal"></span></label>
      <input id="fade" type="range" min="0.85" max="0.99" step="0.005" value="0.94">
    </div>

    <div class="row">
      <label><span>Max Wave Complexity</span><span id="complexVal"></span></label>
      <input id="complex" type="range" min="1" max="60" step="1" value="30">
    </div>

    <div class="row">
      <label><span>Beat Sensitivity</span><span id="sensVal"></span></label>
      <input id="beatSens" type="range" min="0.005" max="0.15" step="0.005" value="0.04">
    </div>

    <div class="row">
      <label><span>Audio Reactivity</span><span id="reactVal"></span></label>
      <input id="react" type="range" min="0" max="2.0" step="0.1" value="1.0">
    </div>

    <div class="row">
      <label><span>Rainbow Brightness â†’ White (max)</span><span id="brightVal"></span></label>
      <input id="bright" type="range" min="0" max="1" step="0.01" value="0.2">
    </div>
  </div>

  <canvas id="c"></canvas>

  <script>
    // ---------- Canvas ----------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    let width = window.innerWidth, height = window.innerHeight;
    canvas.width = width; canvas.height = height;

    window.addEventListener("resize", () => {
      width = window.innerWidth; height = window.innerHeight;
      canvas.width = width; canvas.height = height;
    });

    // ---------- UI ----------
    const fadeSlider     = document.getElementById("fade");
    const complexSlider  = document.getElementById("complex");
    const beatSensSlider = document.getElementById("beatSens");
    const reactSlider    = document.getElementById("react");
    const brightSlider   = document.getElementById("bright");

    const fadeVal    = document.getElementById("fadeVal");
    const complexVal = document.getElementById("complexVal");
    const sensVal    = document.getElementById("sensVal");
    const reactVal   = document.getElementById("reactVal");
    const brightVal  = document.getElementById("brightVal");

    let fadeSpeed       = parseFloat(fadeSlider.value);
    let maxComplexity   = parseInt(complexSlider.value, 10);
    let beatSensitivity = parseFloat(beatSensSlider.value);
    let audioReactivity = parseFloat(reactSlider.value);
    let rainbowBrightnessMax = parseFloat(brightSlider.value); // each sound: random [0, this]

    function refreshUI() {
      fadeVal.textContent    = fadeSpeed.toFixed(3);
      complexVal.textContent = maxComplexity.toString();
      sensVal.textContent    = beatSensitivity.toFixed(3);
      reactVal.textContent   = audioReactivity.toFixed(1);
      brightVal.textContent  = rainbowBrightnessMax.toFixed(2);
    }

    fadeSlider.oninput     = () => { fadeSpeed       = parseFloat(fadeSlider.value);     refreshUI(); };
    complexSlider.oninput  = () => { maxComplexity   = parseInt(complexSlider.value,10); refreshUI(); };
    beatSensSlider.oninput = () => { beatSensitivity = parseFloat(beatSensSlider.value); refreshUI(); };
    reactSlider.oninput    = () => { audioReactivity = parseFloat(reactSlider.value);    refreshUI(); };
    brightSlider.oninput   = () => { rainbowBrightnessMax = parseFloat(brightSlider.value); refreshUI(); };

    refreshUI();

    // ---------- Audio ----------
    const micBtn   = document.getElementById("micBtn");
    const fileInput = document.getElementById("fileInput");

    let audioCtx = null;
    let analyser = null;
    let freqData = null;
    let timeData = null;
    let sourceNode = null;
    let audioElement = null;
    let audioFileSource = null;

    function ensureAudioContext(){
      if(!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function resumeAudioContext(){
      if(audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume();
      }
    }

    function setupAnalyser() {
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = 0.7;
      freqData = new Uint8Array(analyser.frequencyBinCount);
      timeData = new Uint8Array(analyser.fftSize);
    }

    micBtn.onclick = async () => {
      ensureAudioContext();
      resumeAudioContext();
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        if(sourceNode) sourceNode.disconnect();
        setupAnalyser();
        sourceNode = audioCtx.createMediaStreamSource(stream);
        sourceNode.connect(analyser);
      } catch(e) {
        console.error(e);
        alert("Microphone error / permission denied.");
      }
    };

    fileInput.onchange = e => {
      const file = e.target.files[0];
      if(!file) return;

      ensureAudioContext();
      resumeAudioContext();

      if(audioElement) {
        audioElement.pause();
        audioElement = null;
      }

      audioElement = new Audio(URL.createObjectURL(file));
      audioElement.loop = true;
      audioElement.crossOrigin = "anonymous";

      audioElement.addEventListener("play", () => {
        resumeAudioContext();
      });

      audioElement.play().catch(err => {
        console.warn("Autoplay blocked; click the browser's play button if shown.", err);
      });

      if(sourceNode)      sourceNode.disconnect();
      if(audioFileSource) audioFileSource.disconnect();

      setupAnalyser();
      audioFileSource = audioCtx.createMediaElementSource(audioElement);
      audioFileSource.connect(analyser);
      analyser.connect(audioCtx.destination);
    };

    // ---------- Audio metrics & beat detection ----------
    let smoothRms = 0;
    let lastBeatTime = 0;
    const beatTimes = [];

    function getAudioMetrics(t) {
      if(!analyser || !freqData || !timeData) {
        const fake = 0.25 + 0.15 * Math.sin(t * 0.6);
        return {
          energy: fake,
          rms: fake,
          silent: true
        };
      }

      analyser.getByteFrequencyData(freqData);
      analyser.getByteTimeDomainData(timeData);

      const lenFreq = freqData.length;
      const lenTime = timeData.length;

      let freqSum = 0;
      let freqNonZero = 0;
      for(let i = 0; i < lenFreq; i++) {
        const v = freqData[i];
        freqSum += v;
        if(v > 0) freqNonZero++;
      }

      // RMS from time-domain
      let sumSq = 0;
      for(let i = 0; i < lenTime; i++) {
        const centered = (timeData[i] - 128) / 128;
        sumSq += centered * centered;
      }
      const rms = Math.sqrt(sumSq / (lenTime || 1));

      const allZero = (freqNonZero === 0 || freqSum === 0);
      const silent = allZero || rms < 0.003;

      if(silent) {
        const fake = 0.25 + 0.15 * Math.sin(t * 0.6);
        return {
          energy: fake,
          rms: fake,
          silent: true
        };
      }

      // mid-band energy
      const start = Math.floor(lenFreq * 0.08);
      const end   = Math.floor(lenFreq * 0.8);
      let bandSum = 0;
      for(let i = start; i < end; i++) {
        bandSum += freqData[i];
      }
      const avgBand = bandSum / (end - start || 1);
      const energy = Math.max(0.02, avgBand / 255);

      return { energy, rms, silent: false };
    }

    function detectBeat(t, rms, silent) {
      if(silent) {
        const fakeInterval = 60 / 60; // 60 BPM
        if(t - lastBeatTime > fakeInterval) {
          lastBeatTime = t;
          beatTimes.push(t);
          if(beatTimes.length > 12) beatTimes.shift();
          return true;
        }
        return false;
      }

      smoothRms = smoothRms * 0.9 + rms * 0.1;
      const delta = rms - smoothRms;

      const minInterval = 0.18; // ~333 BPM cap
      if(delta > beatSensitivity && (t - lastBeatTime) > minInterval) {
        lastBeatTime = t;
        beatTimes.push(t);
        if(beatTimes.length > 16) beatTimes.shift();
        return true;
      }
      return false;
    }

    // ---------- Waveform loops ----------
    const loops = [];
    let globalHue = 0;

    function spawnLoop(energy) {
      const x = Math.random() * width;
      const y = Math.random() * height;

      const intensity = 0.25 + 0.5 * Math.random() + audioReactivity * 0.6 * energy;

      const baseRadius = 20 + Math.random() * Math.min(width, height) * 0.18;

      const freq = Math.max(1, Math.floor(1 + Math.random() * Math.max(1, maxComplexity)));

      // NEW: each loop gets its own random brightness between 0 and slider max
      const brightness = rainbowBrightnessMax * Math.random();

      loops.push({
        x,
        y,
        baseRadius,
        radius: baseRadius,
        growth: 60 + intensity * 260,
        amp: 0.04 + intensity * 0.24,
        freq,
        phase: Math.random() * Math.PI * 2,
        phaseSpeed: (Math.random() < 0.5 ? -1 : 1) * (0.7 + intensity * 3.0),
        hueBase: (globalHue + Math.random() * 180) % 360,
        alpha: 0.4 + intensity * 0.6,
        thickness: 0.8 + intensity * 3.0,
        brightness // per-loop brightness toward white
      });

      globalHue = (globalHue + 22 + intensity * 88) % 360;
    }

    function drawLoop(L) {
      const segments = 260;
      const twoPI = Math.PI * 2;
      let px = null, py = null;

      const b = L.brightness || 0; // safety

      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const theta = t * twoPI;

        const wobble = 1 + L.amp * Math.sin(theta * L.freq + L.phase);
        const r = L.radius * wobble;

        const x = L.x + r * Math.cos(theta);
        const y = L.y + r * Math.sin(theta);

        if (px !== null) {
          const hue = (L.hueBase + t * 360) % 360;
          const baseLight = 45 + 25 * L.amp * 4;

          // Desaturate as brightness approaches 1
          const sat = Math.max(0, 100 - b * 100);

          // Raise lightness towards 100% with brightness
          const light = baseLight + b * (100 - baseLight);

          ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${light}%, ${L.alpha})`;
          ctx.lineWidth = L.thickness;

          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(x, y);
          ctx.stroke();
        }

        px = x;
        py = y;
      }
    }

    // ---------- Main loop ----------
    let lastTime = performance.now();

    function frame(now) {
      const t  = now / 1000;
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      const { energy, rms, silent } = getAudioMetrics(t);

      ctx.fillStyle = `rgba(0,0,0,${1 - fadeSpeed})`;
      ctx.fillRect(0, 0, width, height);

      const beat = detectBeat(t, rms, silent);
      if (beat) {
        spawnLoop(energy);
      }

      for (let i = loops.length - 1; i >= 0; i--) {
        const L = loops[i];
        L.radius += L.growth * dt;
        L.phase  += L.phaseSpeed * dt;
        L.alpha  *= 0.978;

        if (L.alpha < 0.02 || L.radius > Math.max(width, height) * 2) {
          loops.splice(i, 1);
          continue;
        }
        drawLoop(L);
      }

      requestAnimationFrame(frame);
    }

    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);
    requestAnimationFrame(frame);
  </script>
</body>
</html>
